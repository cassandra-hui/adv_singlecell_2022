---
title: "miloR + slingshot .. continuous DA"
output: html_document
editor_options: 
  chunk_output_type: console
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Load packages

```{r}
suppressPackageStartupMessages({
  library(miloR)
  library(SingleCellExperiment)
  library(dplyr)
  library(tibble)
  library(patchwork)
  library(slingshot)
  library(scater)
  library(scran)
  library(bluster)
  library(grDevices)
  library(RColorBrewer)
  library(reshape2)
})

```

## Read in data, quick peek at low dim projection

```{r}
sce <- readRDS("sce_continuum_demo_public.rds")
plotUMAP(sce, colour_by="condition", shape_by="sample") +
  geom_point(size=3, aes(colour=colour_by, shape=shape_by))
```


## Run miloR analysis

```{r}

# general flow taken from:
# https://www.bioconductor.org/packages/release/bioc/vignettes/miloR/inst/doc/milo_demo.html

# create milo object
milo <- Milo(sce)
reducedDim(milo, "UMAP") <- reducedDim(sce, "UMAP")


# using parameters from vignette, build graph
milo <- buildGraph(milo, k = 10, d = 30)
milo <- makeNhoods(milo, k=10, d=30, 
                       prop=0.1, refined=TRUE)
plotNhoodSizeHist(milo) 

# count by sample for each neighbourhood
milo <- countCells(milo,
                   meta.data=data.frame(colData(milo)),
                   sample="sample")
milo <- calcNhoodDistance(milo, d=30)

nhcnts <- nhoodCounts(milo)

# quick peek at neighbourhood counts
head(nhcnts[,sort(colnames(nhcnts))])


# collect metadata, make design matrix
md <- colData(milo) %>% data.frame() 
md <- md[,c("sample","condition")] %>% unique
rownames(md) <- NULL

design <- md %>% column_to_rownames("sample")

# check
all( colnames(nhcnts) == rownames(design) )

# doing tests for each neighbourhood
milo_res <- testNhoods(milo, design=~condition, design.df=design)

# peek at results
milo_res %>% arrange(SpatialFDR) %>% head(20)


# visualize neighbourhood-wise results in low dim projection
milo <- buildNhoodGraph(milo)
plotNhoodGraphDA(milo, milo_res)
```




## Run `slingshot` analysis

```{r}

clusters <- clusterCells(sce, use.dimred="PCA", BLUSPARAM=NNGraphParam(k=3))
colData(sce)$cluster <- clusters

df <- data.frame(reducedDim(sce, "UMAP")[,1:2], cluster=clusters)
df_agg <- df %>% group_by(cluster) %>% summarise_all(mean)


# quick look on the clustering
plotUMAP(sce, colour_by="cluster") +
  geom_label(data=df_agg, aes(x=X1, y=X2, label=cluster))
  

sling <- slingshot(sce, clusterLabels = 'cluster',
                   reducedDim = 'PCA')

sling_ds <- SlingshotDataSet(sling)

# compare the inferred lineages to the low dim projection
sling_ds


# quick look on the trajectory inference
# bit clunky plotting (probably a better way)
lineages <- c("slingPseudotime_1", "slingPseudotime_2", 
              "slingPseudotime_3")
colors <- colorRampPalette(brewer.pal(11,'Spectral')[-6])(100)
cd <- colData(sling)

par(mfrow=c(1,3))
for(lin in lineages) {
  plotcol <- colors[cut(cd[,lin], breaks=100)]
  plot(reducedDims(sling)$PCA, col = plotcol, pch=16, asp = 1, main=lin)
  lines(SlingshotDataSet(sling), lwd=2, col=c("blue","grey","black"))
}


# transformations of inferred trajectory data
md <- slingPseudotime(sling) %>%
  as.data.frame() %>%
  mutate(cell_id = sling$cell_id,
         condition = sling$condition,
         sample = sling$sample)
head(md, 3)

md_melt <- melt(md)
head(md_melt, 3)

df <- md %>% select(contains("Lineage")) %>%
  mutate(cluster=clusters)
head(df, 3)
df_agg <- df %>% group_by(cluster) %>% summarise_all(mean, na.rm=TRUE)
head(df_agg, 3)


lin <- "Lineage2"
ggplot(md_melt %>% filter(variable==lin)) +
  geom_density(aes(x = value, fill = condition, group = sample), alpha = .5) +
  geom_label(data=df_agg, aes(Lineage2, y=0, label=cluster))


# how to do formal testing -- distinct?

```



